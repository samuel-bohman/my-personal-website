---
title: The K-Means Algorithm
author: Samuel Bohman
date: "2017-10-04"
tags: 
  - unsupervised learning
  - k-means
slug: the-k-means-algorithm
output: blogdown::html_page
summary: "A brief tutorial on the k-means algorithm."
---



<p>K-means is one of the most popular clustering algorithms. The goal of the K-means algorithm is to partition a data set into a desired number of non-overlapping clusters <span class="math inline">\(K\)</span>, so that the total <em>within-cluster variation</em> <span class="math inline">\(W(C_K)\)</span> is minimized. Formally, we want to solve the problem:</p>
<p><span class="math display">\[
\ \min_{C_1,...,C_K} \left \{ \sum_{k=1}^K W(C_K) \right \}
\]</span></p>
<p>This is in fact a very difficult problem to solve precisely, since there are almost <span class="math inline">\(K^n\)</span> ways to partition <span class="math inline">\(n\)</span> observations into <span class="math inline">\(K\)</span> clusters. Fortunately, the K-means algorithm can find a pretty good solution to this problem.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<pre class="r"><code>load(&quot;cluster.RData&quot;)
set.seed(5)

my_dist &lt;- function(a, b, metric = &quot;euclidean&quot;) {
  if (metric == &quot;manhattan&quot;) {
    dist &lt;- sum(abs(a - b))  # manhattan distance
  } else {
    dist &lt;- sqrt(sum((a - b) ^ 2))  # Euclidean distance
  }
  return(dist)
}

k_means &lt;- function(x, k, max.iter = 20) {
  random_index &lt;- sample(1:k, nrow(x), replace = TRUE)
  data_with_cluster &lt;- cbind(x, clusterID = random_index)
  iterations &lt;- 1
  plot(data_with_cluster[, 1:2])
  while(TRUE) {
    centroids &lt;- matrix(rep(0, times = k * ncol(x)), nrow = k, ncol = ncol(x))
    for(i in 1:k) {
      obs_of_cluster_i &lt;- data_with_cluster$clusterID == i
      centroids[i, ] &lt;- colMeans(data_with_cluster[obs_of_cluster_i, 1:2])
    }
    dist_from_centroids &lt;- matrix(rep(0, nrow(x) * k), nrow = nrow(x), ncol = k)
    for(i in 1:nrow(x)) {
      for(j in 1:nrow(centroids)) {
        dist_from_centroids[i, j] &lt;- my_dist(x[i, ], centroids[j, ])
      }
    }
    obs_new_clusterID &lt;- apply(dist_from_centroids, 1, which.min)
    if(all(obs_new_clusterID == data_with_cluster$clusterID)) {
      km.clusters &lt;- obs_new_clusterID
      centroid.matrix &lt;- centroids
      break
    } else if (iterations &gt; max.iter) {
      break
    } else {
      data_with_cluster$clusterID &lt;- obs_new_clusterID
      iterations &lt;- iterations + 1
    }
    plot(data_with_cluster[, 1:2], col = data_with_cluster$clusterID)
    points(centroids[, 1:2], pch = 20, cex = 2, col = 1:k)
  }
  return(list(&quot;clusters&quot; = km.clusters, &quot;centroids&quot; = centroid.matrix))
}

km_clusters &lt;- k_means(cluster.data, k = 3, max.iter = 15)</code></pre>
<p><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-1.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-2.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-3.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-4.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-5.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-6.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-7.png" width="672" /><img src="/post/2017-10-04-clustering_files/figure-html/unnamed-chunk-1-8.png" width="672" /></p>
<p>Algorithmic properties: - NP-hard if <span class="math inline">\(d &gt;= 2\)</span><br />
- Finding the best solution in polynomial time is infeasible<br />
- For <span class="math inline">\(d = 1\)</span> the problem is solvable in polynomial time<br />
- Finds a local optimum<br />
- Often converges quickly<br />
- Relative efficient<br />
- Guaranteed to converge after at most <span class="math inline">\(K^N\)</span> iterations<br />
- Choice of initial points can have a large influence on the result</p>
</div>
